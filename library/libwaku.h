
// Generated manually and inspired by the one generated by the Nim Compiler.
// In order to see the header file generated by Nim just run `make libwaku`
// from the root repo folder and the header should be created in
// nimcache/release/libwaku/libwaku.h
#ifndef __libwaku__
#define __libwaku__

// The possible returned values for the functions that return int
#define RET_OK                0
#define RET_ERR               1
#define RET_MISSING_CALLBACK  2

#ifdef __cplusplus
extern "C" {
#endif

typedef void (*WakuCallBack) (const char* msg,
                              size_t len_0,
                              void* userData);

// Initializes the waku library and returns a pointer to the Context.
void* waku_init(WakuCallBack onErrCb,
                void* userData);

// Creates a new instance of the waku node.
// Sets up the waku node from the given configuration.
int waku_new(void* ctx,
             const char* configJson,
             WakuCallBack onErrCb);

int waku_start(void* ctx,
               WakuCallBack onErrCb);

int waku_stop(void* ctx,
              WakuCallBack onErrCb);

int waku_version(void* ctx,
                 WakuCallBack onOkCb);

void waku_set_event_callback(WakuCallBack callback);

// Attaches the user-defined data to the current context.
// The user data is only needed in Rust to allow proper
// feedback through a closure callback.
void waku_set_user_data(void* ctx, void* userData);

int waku_content_topic(void* ctx,
                       const char* appName,
                       unsigned int appVersion,
                       const char* contentTopicName,
                       const char* encoding,
                       WakuCallBack onOkCb);

int waku_pubsub_topic(void* ctx,
                      const char* topicName,
                      WakuCallBack onOkCb);

int waku_default_pubsub_topic(void* ctx,
                              WakuCallBack onOkCb);

int waku_relay_publish(void* ctx,
                       const char* pubSubTopic,
                       const char* jsonWakuMessage,
                       unsigned int timeoutMs,
                       WakuCallBack onErrCb);

int waku_relay_subscribe(void* ctx,
                         const char* pubSubTopic,
                         WakuCallBack onErrCb);

int waku_relay_unsubscribe(void* ctx,
                           const char* pubSubTopic,
                           WakuCallBack onErrCb);

int waku_connect(void* ctx,
                 const char* peerMultiAddr,
                 unsigned int timeoutMs,
                 WakuCallBack onErrCb);

#ifdef __cplusplus
}
#endif

#endif /* __libwaku__ */
